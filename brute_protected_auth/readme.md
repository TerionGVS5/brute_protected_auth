### Задание:
Необходимо разработать миксин для бекендов авторизации DRF и Django для предотвращения попыток подбора пароля к пользователям сервиса. При реализации можно использовать любые версии DRF>=3, Django>=1.11
Миксин должен реализовывать следующую функциональность:
 Сохранять на период **SECONDS_FOR_SAVE_ERROR_ATTEMPTS** неуспешные попытки входа пользователя. Информация является не критичной к разовым потерям и не требует хранения для статистики входов.
 Учитывать возможность высокой нагрузки на сервис. 
 При превышении числа **POSSIBLE_ERROR_ATTEMPTS** количества неудачных попыток входа пользователя за период **SECONDS_PERIOD_FOR_CHECK_ATTEMPTS**, полностью блокировать доступ к сервису через бекэнд с этим миксином на **SECONDS_FOR_BLOCK_USER** для этого пользователя.
___
1. Так как не требуется хранить информацию для статистики и нужна высокая
производительность было решено использовать **Redis**
2. Для запуска приложения требуется установленные: **Docker, Docker Compose** 
(тестировалось на Docker 19.03.5, Docker Compose 1.21.2)

#### Запускать тесты через **docker-compose-test.yaml**

#### Запускать проект через файл **docker-compose.yaml**

Там уже будет база с дампом и пользователем: 
Логин:**Giorno** Пароль:**Giovanna**

1. Для стандартной Django url требующий авторизации:

    http://127.0.0.1:8055/common-django-app/v1/common-django-view

    При переходе по нему - если пользователь авторизирован - он увидит:

    `Hello Giorno`

    Если не авторизован - то будет перенаправлен на страницу авторизации,
    после успешной авторизации - будет перенаправлен на страницу с указанным ранее текстом.

2. Для DRF url требующий авторизации (используется **Basic Auth + Postman**)
    
    http://127.0.0.1:8055/api/common-drf-app/v1/common-drf-api-view
    
    после успешной авторизации вернётся ответ:
    
    `{
    "result": "Hello Giorno"
    }`
    
    
    